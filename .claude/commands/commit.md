# 論理的分割コミット

## 基本プロンプト

```
論理的な分割でcommit
```

## 詳細プロンプト（カスタマイズ用）

```
変更内容を論理的に分析して、以下の基準で段階的にcommitしてください：

1. **機能単位での分割**:
   - 新機能追加
   - バグ修正
   - リファクタリング
   - 設定変更

2. **影響範囲での分割**:
   - コア機能の変更
   - UI/UXの改善
   - ビルド/設定の変更
   - ドキュメント更新

3. **依存関係を考慮**:
   - 他の変更に依存しない独立した変更から順番に
   - 設定ファイル → コア機能 → UI → ドキュメントの順序

4. **コミットメッセージ規則**:
   - feat: 新機能
   - fix: バグ修正
   - refactor: リファクタリング
   - chore: 設定変更・ツール更新
   - docs: ドキュメント更新
   - style: コードスタイル変更

各コミットで詳細な変更理由と影響範囲を日本語で説明してください。
```

## 使用例

### 基本的な使用

```
論理的な分割でcommit
```

### 特定の分割基準を指定

```
次の基準で論理的分割コミット：
1. TypeScript型定義の追加
2. ログシステムの導入
3. UI改善
4. ドキュメント更新
```

### 特定ファイルのみ対象

```
src/ディレクトリの変更のみを論理的分割でcommit
```

## 自動分析される項目

1. **変更ファイルの分類**
   - ソースコード (src/)
   - 設定ファイル (package.json, tsconfig.json, etc.)
   - ドキュメント (docs/, .claude/, README.md)
   - ビルド/デプロイ関連

2. **変更の性質**
   - 新規追加
   - 既存修正
   - 削除
   - 移動/リネーム

3. **依存関係の分析**
   - どの変更が他に影響するか
   - 独立してコミット可能な変更の特定

4. **コミット順序の最適化**
   - 安全な順序での段階的コミット
   - ビルドが通る状態での各コミット

## 期待される出力

1. **変更内容の分析結果**
2. **論理的な分割計画の提示**
3. **各グループの段階的コミット実行**
4. **日本語での詳細な変更説明**
5. **最終状態の確認**

## 注意事項

- 各コミット後にビルドエラーが発生しないよう配慮
- 関連する変更は同一コミットにまとめる
- 独立性の高い変更から優先的にコミット
- コミットメッセージは変更の「なぜ」を重視
